# 1

- if 表达式有值
- 快有值
- scala的for循环就像“增强”的java for循环
- 分好，不算必须的
- void类型是Unit
- 避免使用return
- 注意别再函数式定义中漏掉 =
- 异常处理与java/c++基本一样，不同的是可以在catch中使用“模式匹配”
- scala没有受检异常

## if else

看例子：

val s=if(x>0) 1 else -1

和下面一样

if(x>0) s=1 else s=-1

## 语句终止

## 块表达式和赋值

## 输入和输出

## 循环

## 高级for循环和for推导式

for(i <- 1 to 3;j <- 10 to 80 if i!=j)

用 `变量 <- 表达式` 的形式提供多个生成器， `;` 分隔

每个生成器可以带一个守卫，以 if 开头的Boolean表达式，不过 if之前没有分号

可以使用任意多的定义，引入可以在循环中使用的变量

如果 for循环的循环体以 yield开始，则循环会构造出一个集合，每次迭代生成集合中一个值

for(i <- 1 to 10 ) yield 1% 3
// 生成 Vector(1,2,0,1,2,0,1,2,0,1)
for(c<-"Hello";i<-0 to 1) yield (c+i).toChar
// 生成 "HIeflmlmop"
for(i<- 0 to 1,c <- "Hello") yield (c+i).toChar
// 生存Vector('H','e','l','l','o','l','f','m','m','p')

## 函数

scala除了方法外，还支持函数。方法对对象进行操作，函数不是。

例如 ： def abs(x:Double) = if(x>=0) x else -x

必须给出所有参数类型，但是只要函数不是递归的，就不用指定返回值，scala通过 = 右侧表达式推断返回类型

## 默认参数和带名参数

- 形参 可以给默认值，调用的时候，有默认值的参数可以不传值

- 例： def tt(str : String = "hello") = str

- 给的参数如果数量不够，会按顺序匹配（首先要不报错）

- 调用的时候给参数可以带名使用例如： tt(str="world"),这种情况下，如果有多个参数，就可以不用在意顺序了，并且函数更可读

- 可以混用未命名参数和带名参数，要求 未命名参数是排在前面的

## 变长参数

def sum(args : Int*)={
    var result = 0
    for(arg <- args) result += arg
    result
}

- 这种情况，函数得到一个类型为Seq的参数，但是不能把一个Seq传进去

- 正确例子： sum(1,2,3)
- 错误例子： sum(1 to 5)

- sum函数被调用时传入的是单个参数，那么该参数必须是单个整数，而不是一个整数区间。解决方法是：告诉编译器你希望这个参数被当作参数序列处理。追加  :_*
  - val s = sum(1 to 5:_*) //递归调用在这里有用应

## 过程

scala对于不返回值的函数有特殊的表示法。如果函数体包含在{}当中，但是没有在前面的 = 号，那么返回着就是Unit。这样的函数被称作过程 procedure。过程不返回值，我们调用它仅仅是为了他的副作用，例如，打印

## 懒值

当 val 被声明未 lazy时，它的初始化将被推迟，知道我们首次对它取值。例如：

lazy val words = scala.io.Source.formFile("/...").mkString

可以把 懒值当作 val和def的中间状态

```note
懒值并不是没有额外开销，每次访问懒值，都会有一个方法被调用，以线程安全的方式，检查该值是否已经被初始化
```

## 异常

scala异常工作机制和java或者 c++ 一样。

当前的运算被终止，运行时系统查找可以接受 异常 的异常处理器，控制权将在离抛出点最近的处理器中恢复。如果没有找到合适的处理器，则程序退出。

scala没有 受检 异常 —— 不需要声明函数或方法可能会抛出某种异常