#

- 聊天
- 社交
- LBS
- 推送服务

## 聊天（不完全）

- 相比于传统网络，移动网络有两个特点：若网络型，对流量敏感
  - 信号不稳定，响应时间长，丢包
  - 需要尽量减少通讯次数
  - 有可能断网了服务器还不知道，所有要有必要的心跳（但影响性能）
  - 三种用于服务器检查App连接的方式
    - 1.记录心跳时间，定期检查，超时断开（需要同时检查所有连接，所以影响性能）
    - 2.为连接建立定时器，收到心跳就重设，超时就断开（有可能有很多定时器，影响性能）
    - 3.实践轮片
      - 假设超时时间60秒，那么设置60个桶，分别放 1s，2s，3s，。。。60s后超时的连接，每秒把第一个桶清空，放到队尾，循环起来。
  - 关于流量敏感
    - 手机提示app消耗流量多，用户直接给删了
  - 协议（聊天协议）
    - XMPP ，基于XML消息协议，耗流量
    - MQTT 
    - ActivitySync ：微信用的
    - 上面三个用的最多的还是XMPP，另外用第三翻IM服务也可以
    - 两个开源的基于XMPP协议的聊天服务器
      - Ejobberd
      - Openfire
    - 通信协议一般是TCP协议，TCP协议是一种面向连接，流，提供可靠服务的协议。

## 社交（微博类功能）

社交的核心功能是Feed：用户通过关注功能，聚合被关注用户最新的内容和自己的内容，以供自己浏览。

Feed架构
- 基本表结构
- 推拉模式
- 数据库架构
- 缓存架构

### 基本表结构

- 一般数据存储在MySQL
- 热点数据存储在Redis/Memcached
  - 大多数请求通过缓存直接返回

- 一个简单的Feed架构
  - MySQL中，四张表
    - send_content 用户发表内容
      - feed_id
      - author_id
      - content
    - reveive_content 用户接收内容
      - feed_id
      - author_id
      - receive_id
      - content
    - followings 关注
      - user_id
      - following_id
    - followers 粉丝
      - user_id
      - follower_id
- 推拉模式
  - 推模式
    - 1. id为 user1 的用户发表“你好”消息
    - 2. 这条内容写入 sent_content
      - feed_id:1,author_id:user1,content:"你好"
    - 3. 在粉丝表中找到 user1 的所有粉丝
    - 4. 把 这条信息 和 粉丝的id 组合起来，写入 receive_content表里面
    - 5. 当用户查看自己的信息的时候，就能看到 “你好” 了
    - 缺点
      - 同时推给很多人，延迟高，浪费很多存储
      - 变更操作成本高
  - 拉模式
    - 1. user1 发表 “大家好”
    - 2. 内容写入 send_content
    - 3. user2 登陆，在followings里面找关注的用户
    - 4. 通过关注的用户 关联出 user1 发送的内容
    - 缺点
      - 时间换空间，需要聚合运算
  - 推拉模式总结
    - 一个空间，一个时间
  - 微博的用法
    - 公开的微博用拉模式
    - 私密的用推模式
    - 拉模式的时间问题，通过缓存架构解决
### 数据库架构演进
- 单机
- 读写分离
- 分表分库
- 社交分表分库方案（以后再看把）

### 缓存架构的演进

- 1. 分布式缓存
  - 问题1：后台中有多台缓存服务器，怎样确定某个数据缓存在哪台服务器
  - 问题2：如何让数据均衡的分布在缓存中
  - 方案1：余数hash
    - 服务器数量除缓存数据key值的hash，余数作为缓存服务器的编号
    - 缺点：服务器数量变化，造成大震荡
  - 方案2：一致性hash
    - 麻省理工 ： 分布式哈希（DHT）实现算法
    - 构造一个长度为0~unsigned-int-Max的圆环（一致性hash环），根据缓存服务器名称的hash值，把服务器放在这个环上。当请求到达，计算key的hash，放到最近的服务器上
    - 问题：服务器负担不均衡（没看详细分析）
    - 解决：虚拟节点
- 2. 主从缓存
  - 解决宕机问题
  - 更新数据，先从主缓存获取数据，然后一致性更新，更新成功后再更新从缓存，如果主缓存一致性更新
- 3. 防止缓存失效
  - 首先由一点，从缓存一般很少被使用到，所以数据更可能被过期策略删除
    - 定期把主缓存数据同步到从缓存：但是同步的时候对正常业务有影响
    - 应用层控制请求有一定概率落在从缓存上，让其不至于过冷

## LBS App 后台架构 Location Based Service

- 暂不学习

## 推送服务器后台架构