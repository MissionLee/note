# 分布式锁

- 这里讨论基于Redis实现的分布式锁，但是原理是相同的

- 需要考虑的内容
  - 仅有一个节点-进程-线程可以获取锁
  - 防止死锁
  - 效率

> 在Redis模块，我收藏了几篇Redis实现分布式锁的文章，其中多篇文章分析过后，实际的可用性都不高，仅有一篇实现较为合理，但也并不是完美的解决这个问题。

文章的几个问题

- 1. 使用了 synchronized 都是逗逼
  - 所有使用了 synchronized 关键词的-攻略-，实际上都没有理解分布式锁的真正需求

> 我们在使用分布式锁的时候，首先考虑的肯定是 “锁” 这个功能的实现，此时即使在方法中用到 synchronized 这个关键词，也不影响 “锁”的目的， 在锁的时候，我们是希望 “被锁的内容尽可能具体” ，直接锁方法的效率一定是极低的，并且，我们开发的是“锁”的底层类，如果一个项目里面，所有不同的功能，所有不同的业务，所有业务中的主体都 “被锁在同一个位置”，那么这个方法肯定是不可取的。

- 2. 强行解锁/防止死锁的方式的方式 （ 权衡之下，我觉得 思路1 可能好一些 ，舍弃认证， ）
  - 思路 1 （问题：没法进行解锁认证）：锁key，然后再value里面存储，过期时间，其他人在尝试获取锁的时候，如果根据value里面的值，发现当前锁已经失效，那么就会强行获取这个锁
    - 缺点1： 解锁没有身份认证，锁可以被非加锁者解开
      - 我曾经想过给这种方式加上 uuid 作为解锁认证，但是
        - 1.强制解锁的时候，是不能考虑uuid的情况的
        - 2.多个节点强制解锁，下面 `缺点2` 也会造成redis中记录的uuid，和实际获得锁许可的节点不统一。
    - 缺点2： 强行解锁的时候，会存在多个节点并发解锁的情况（此种情况，没法加上解锁认证）
      - 缺点2 实际上有解决方法，Redis分布式锁， 攻略文章4 用的就是 getSet的方式 - 这里明确，由于redis底层单线程操作，所以一定时某个getSet方法限制性，另外的后执行，然后通过返回的旧的值，来判断当前线程是否竞争成功
  - 思路 2（问题，自动删除并非总是合理） ： 锁key value为当前线程的id ，强行解锁的方式为 key的时间过期，自动删除
    - 缺点1 ： 自动删除
  - 思路3 （已证实不合适）
    - 不用 k-v 改用 k-hash，存储所有并发状态下的 uuid集合
    - 这个方法实现不了，不支持，不具体说明了
  - 思路4 ： 不美观的终极解决方法
    - 与需要锁的业务代码整合，在正常解锁之外，对业务代码本身进行try-catch，然后解锁，做到除了服务挂掉，都能正确解锁的这种情况

> 总结： 从实用和小路，最优的解法， 思路4 + 思路1 ，思路2理论上能够解决很多问题，但是从效率/负荷上将会有不少影响

```java
// 思路1

// 思路2