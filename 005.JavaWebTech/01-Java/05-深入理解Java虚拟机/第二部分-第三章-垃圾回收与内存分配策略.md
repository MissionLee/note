# 第二部分第三章 垃圾回收与内存分配策略

> 栈区(程序计数器，虚拟机栈，本地方法栈)的内存具有确定性，入栈申请，出栈释放。
>
> 而
>
> 堆 与 方法区则要考虑更复杂的分配与回收问题（方法区要回收的垃圾比较少）

## 判断对象死了吗

### 引用计数算法 Reference Counting（通常不用）

- 引用了 就 ++ ，失效了就 -- 
- 问题：循环引用



### 可达性分析算法 Reachability Analysis（主流实现）

> 主流实现

- 通过一系列称为 GC Roots 的对象作为起点，从这些节点开始乡下搜索，搜索走过的路径称为 Reference Chain。
- Reference Chain 没有到达的地方，说明对象是不可用的了
- GC Roots 
  - 虚拟机栈（栈帧中的本地变量表）中引用的对象
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法中JNI(Natice方法)引用的对象

### 引用

最初引用只有两种状态：是与否 。 如果reference类型的数据中存储的数代表另一块内存的起始地址，那么这块内存代表着一个引用。

但是，有些时候，我们希望内存空间足够的时候，即使没有用，一些内容也能保存下来。

- 强引用 Strong Reference
  - 不会回收
- 软引用 Soft Reference
  - 如果内存不够了，会回收
- 弱引用 Weak Reference
  - 只要GC，会回收，
- 需引用 Phantom Reference
  - 就连获取对象实例都不能
  - 唯一作用就是对象被回收的时候，可以收到一个通知

### 生存于死亡

即使可达性算法中达不到的对象，也并非“非死不可”。至少经过两次标记，才会宣告真正死亡。

- 第一次标记：发现对象没有于GC Roots连接，会被第一次标记，并且进行以此筛选，条件是-此对象是否又必要执行finalize()方法。
  - 情况1 对象没有覆盖 finalize 方法
  - 情况2 finalize 方法已经被调用过了
  - 这两种情况都会十位“没有必要执行”
- 如果又必要执行，那么这个县城会被防止在F-Queue队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去等待其运行结束
  - finalize 可以执行缓慢，或者发生死循环。可能让F-Queue队列中其他对象永久处于等待，甚至回收系统崩溃
- 第二次标记：GC对F-Queue中的对象进行第二次小规模标记，如果对象在finalize 方法中拯救了自己（回到引用链上，例如把this赋值给了某个类变量或对象的成员变量）  那么，第二次标记的时候会被移除回收列表
  - 自救代码有时候会成功，有时候会失败，因为任何一个对象的finalize 方法都只会被系统自动调用以此
  - 减少这种使用

### 回收方法区

Java虚拟机规范不要求方法区实现垃圾收集，因为性价比很低，不过实际上还是有一些回收的。

主要回收内容

- 废弃常量（类，接口，方法，字段）
  - 类似Java堆中对象的回收
- 无用的类，要同时满足三个条件，才允许回收，但不是必定
  - 该类所有实例都被回收了（堆里面没有实例）
  - 加载该类的 ClassLoader 被回收了
  - 类对象  java.lang.Class 对象没有在任何地方被引用

## 垃圾收集算法

### 标记清除算法 Mark-Sweep 

- 最基础的算法
- 两点不足
  - 效率：标记清楚两个过程，效率都不高
  - 空间：标记清除后产生大量不连续的内存碎片

### 复制算法 Copying

为了解决效率问题，将内存分为大小相等的两块，其中一块用完了，把或者的对象复制到另一块，当前块清理掉。

这样做的代价也很高

> 现在商业虚拟机都采用这种算法回收新生代，不过比例不是1：1.

- 商业虚拟机，新生代上的应用（根据研究 新生代中98% 的对象“短命”）
  - 一块较大的Eden空间 和 两块较小的Survivor空间，每次使用 Eden和一个Survivor
  - 回收是，Eden 和 Survivor 中 存活的对象 放到另一个 Survivor上
  - HotSpot 默认Eden：Survivor 为 8：1
  - 当Survivor不够的时候，以来其他内存（老年代）进行分配担保（Handle Promotion）

### 标记-整理算法

老年代常用算法。所有或者的对象向一段移动，清理掉边界以外的内存

### 分代收集算法 （都用这个）

一般Java堆分为 新生代，老年代，然后用各自合适的算法（前面两种）

## HotSpot的算法实现

- 枚举根节点
  - 存在问题
    - 有些时候，GC Roots 本身久会很大，检查起来小号很多时间
    - 工作必须在一个能确保一致性的快照中进行： 这里一致性的意思是指在整个分析期间，整个系统看起来就像被冻结在要给时间点。 =》 看起来GC导致程序停顿。
  - 目前主流Java虚拟机都是：准确式GC。所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。
  - 在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。
- 安全点 Safepoint
  - 在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。
  - 实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。
  - Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint
  - 对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。
- 安全区域 Safe Region
  - 使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。
  - 安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。
  - 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。



## 垃圾收集器

- HotSpot虚拟机的垃圾收集器
  - Young generation
    - Serial
    - ParNew
    - Parallel Scavenge
  - Tenured generation
    - CMS
    - Serial Old(MSC)
    - Parallel Old
  - Young & Tenured
    - GI

- 理解GC 日志



## 内存分配与回收策略

> 对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配[1]），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。
>
>   接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。本节下面的代码在测试时使用Client模式虚拟机运行，没有手工指定收集器组合，换句话说，验证的是在使用Serial/Serial Old收集器下（ParNew/Serial Old收集器组合的规则也基本一致）的内存分配和回收的策略。读者不妨根据自己项目中使用的收集器写一些程序去验证一下使用其他几种收集器的内存分配策略。

### 对象优先在Eden分配

- 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

### 大对象直接进入老年代

- 所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。

### 长期存活的对象将进入老年代

- 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。

### 动态对象年龄判定

- 为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

### 空间分配担保

- 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。