# 第二部分 - 自动内存管理机制

## 第二章 Java内存区域与内存溢出异常

### JAVA-虚拟机运行时数据区 (整理了xmind，一定要配合看，两者互为补充)

#### 所有线程共享的数据区

##### 方法区 Method Area

- [详解方法区](./详解方法区.md)

- 类信息 + 常量 + 静态变量 

- （Java虚拟机规范把方法去描述为堆的一个逻辑部分，但他有个别名：Non-Heap）

- 用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
  - 其中类的信息
    - 类变量（Class Vairables ： 译者：就是类的静态变量，至于类有关）
      - 类变量被类的所有实例共享，即使没有类实例时你也可以访问它。这些变量只与类相关，所以在方法区中，它们成为类数据在逻辑上的一部分。在jvm使用一个类之前，它必须在方法区中为每个non-final类变量分配空间。
    - 字段（描述）
    - 方法（描述）
      - 返回值类型
      - 参数数量和类型（有序）
      - 方法修饰符
      - 异常表
    - 常量池
      - 这个类型用到的常量的一个有序集合
      - 包括
        - 实际的常量（string,integer,浮点类型）
        - 对类型
        - 域
          - 域名
          - 域类型
          - 域修饰符（public,private ,protected,static,final ,volatile,transient）的某个子集
        - 方法的符号引用
      - 池中数据项 类似 数组项，通过索引访问
      - 因为常量池存储了一个类型所使用到的所有类型，域和方法的符号引用，所以它在java程序的动态链接中起了核心的作用
    - 类名
    - 访问修饰符
    - 对类加载器的引用
      - jvm必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。
- 对于在HotSpot虚拟机上开发，部署程序的人来说，他们把方法去称为“永久代”（Permanent Gereration），这样方便GC。对于其他虚拟机不存在永久代的概念。实际上HotSpot一计划放弃这种规划。
- Java虚拟机规范堆方法区限制非常宽松，除了不需要连续内存，可扩展也可固定大小，还不必须实现GC
- 运行时常量池 - 方法去的一部分
  - Class文件文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息就是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，Class加载后，放入方法区运行时常量池
  - Java语言并不要求常量必须在编译期产生，所以运行期间也可能将新的常量放入，这种特性使用的较多的时： String.intern()方法。
  - OutOfMemoryError 异常

##### 堆 Heap

- 一般，Java堆时Java虚拟机管理的内存中最大的一块。
- 作用：存放对象实例，几乎所有对象/数组都在这里分配内存
  - 这句话不是绝对如此：随着JIT编译器发展，逃逸分析技术成熟，栈上分配，标量替换优化技术会导致一些变化。
- Java堆时垃圾收集器的管理区域： GC堆 - Garbage Collected Heap，（分代收集算法）因此Java堆可以细分： 新生代+老年代；更细致的有：Eden空间，From Survivor空间，To Survivor空间等
- 从内存分配角度看，线程共享的Java堆可能划分出多个线程私有的： Thread Local Allocation Buffer.TLAB。但是无论如何划分，都与存放内容无关，无论哪个区域，存储的都依然是对象实例，划分也只是为了更好的回收内存或者分配内存
- -Xmx 堆最大值
- -Xms 堆最小值
- 报错：如果没有内存分配实例，堆也没法扩展 ： OutOfMemoryError

#### 线程隔离的数据区（栈）

##### 虚拟机栈 VM Stack（局部变量表）

- 线程私有，生命周期与线程相同。
- 描述Java方法执行的内存模型
   - 每个方法在执行时会创建一个 栈帧Stack Frame： 用于存储 局部变量表，操作数栈，动态链接，方法出口等信息。
   - 每调用一个方法到执行完成，就对应一个栈帧在虚拟机栈 中 入栈到出栈的过程 
  - 局部变量表
    - 基本类型数据 boolean byte char short int float long double
    - 对象**引用**
       - reference类型，可能是对象起始地址的指针，可能是指向一个代表对象的句柄或其他与此对象相关的位置
    - returnAddress类型（指向一条字节码指令的地址）
    - 注意： long 和 double 会占用2个局部变量空间（slot），其余的占用 1 个
- 在Java虚拟机中对这个区域规定了两种异常
   - StackOverFlowError： 线程请求的栈深度大于虚拟机所允许的
   - OutOfMemoryError： 如果虚拟机栈可以动态扩展（一般都可以），如果扩展时无法申请到足够的内存，会出现这个错误

##### 本地方法栈 Native Method Stack

- 为虚拟机使用的Native方法服务。在虚拟机规范中对本地方法栈中使用的语言，方式与数据结构都没有强制规定，因此虚拟机可以自有实现它。
- 报错情况与VM Stack一样

##### 程序计数器 Program Counter Register

- 一个小块空间，可以看作是当前线程所执行的字节码的行号指示器
- 由于Java虚拟机的多线程是通过线程轮流切换分配处理器执行来完成的，为了线程切换后能恢复到正确位置，每个线程都需要一个独立的计数器
- 如果正在执行Java方法，会记录虚拟机字节码指令地址； 如果是Native方法，为null。

#### 直接内存

- Direct Memory ，不是虚拟机运行时数据区的一部分，也不在规范中，但是频繁的使用，可报错：OutOfMemoryError
- JDK 1.4中加入了NIO （New Input/Output）类，引入了一种基于通道（channel）与缓冲区的（Buffer）的I/O方式，可以使用native函数库直接分配对外内存，然后通过一个存储咋Java堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。在一些场景中性能显著提升，因为避免了在Java堆和native堆中来回复制数据。
- 虽然不受Java堆大小限制，但是还是受到本机总内存等限制。

### HotSpot虚拟机对象探秘

#### 对象的创建

> 在语言层面上，创建对象通常用 new 关键字就行了，而在虚拟机中，对象（普通对象，不包括数组，Class对象等）创建是尤其过程的

- 遇到new指令时，首先区检查这个指令的参数，是否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有会进行这个过程（第七章中探讨）

- 虚拟机为新生对象分配内存。加载完成后可以确定内存所需大小。
  - 理想方法：“指针碰撞” Bump the Pointer
  - 实际上：“空闲列表” - 维护一个列表，记录哪些内存可用，然后分配并更新这个列表
  - 除了空间划分，还有一个问题：对象创建很频繁，仅仅修改指针指向的位置，在并发的情况下不安全。
    - 方案1：堆分配内存动作进行 同步处理 ：实际上采用CAS配上失败重试的方式保证更新操作的原子性
    - 方案2：把内存分配动作，按照县城划分在不同空间中进行：每个线程预先分配一小块，称为**本地县城分配缓冲 Thread Local Allocation Buffer.TLAB**
      - 用-XX：+/-UserTLAB参数来设定
- 内存分配完后，将内存空间初始化为零值（不包括对象头）。这个操作保证对象的实力字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的 **零值**
- 接下来对对象进行必要的设置，例如：对象是那个类的实例，如何找到类的元数据信息，对象的hash，对象的GC分代年龄等。这些信息都放在**对象头**之中。根据虚拟机当前状态不同（例如是否启用偏向锁），会有不同的设置方式。
- 以上工作完成，从虚拟机的角度看，一个新的对象已经产生了，但是从Java程序的视角来看，对象创建刚刚开始
  - \<init>方法此时开始执行，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才完全生成出来。

#### 对象的内存布局

- 对象头 Header
  - Mark Word： HashCode ，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等
  - 类型指针：对象指向他的类元数据的指针，虚拟机通过这个指针来确定对象是那个类的实例。
  - 另外：如果对象是个Java数组，那么头中还有一块用于记录数组长度的数据。
- 实例数据 instance Data
  - 对象真正存储的有效信息：父类子类的都记录下来，存储顺序首都奥虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中的定义顺序影响
- 对其填充 Padding
  - 占位符
  - Java对象大小必须是8字节的整数倍

#### 对象的访问定位

> 使用对象，需要通过栈上的 reference数据来操作堆上的具体对象。
>
> ！ 这个因虚拟机类型不同有差异

- 如果用句柄访问的话，Java堆内会划分出一个句柄池，reference中存储对象的举兵地址，而句柄中包含了对象实例数据和数据类型各自的具体地址信息
  - 栈（Stack） -> 句柄池（Heap）-> 实例池（对象实例数据）/方法区（对象类型数据）
- 如果使用指针访问，那么Java堆对象的布局中就必须考虑如何放置类型数据的相关信息，而reference中存储对象地址
  - 栈 -> 堆（对象实例） -> 方法区（对象类型信息）
  - 对象中存储对象类型数据的指针，以此区方法区找
- 优缺点
  - 句柄的好处是对象被移动（GC的时候），只需要改变实例数据指针，reference本身不用修改
  - 指针好处是速度更快

### 实战 OutOfMemory异常 - Java虚拟机参数

> 通过异常信息，判断哪个区域内存溢出，知道后续如何处理

#### Java堆溢出

原因：对象太多了

异常：可能是应该GC的没GC（内存泄漏 Memory） 或者 就是内存溢出

处理：内存泄漏：找到泄露原因代码，解决掉。 内存溢出，看看还能不能调整最大heap，或者减少一些对象的生命周期

#### 虚拟机栈和本地方法栈溢出

栈深度超出限制会 StackOverFlowError，扩展栈的时候无法申请到足够内存会OutOfMemoryError。 前者是用的太多，后者是给的太少。

使用 -Xss参数调整栈内存容量

这一点读者需要在开发多线程的应用时特别注意，出现StackOverflowError异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的，所以只能说在大多数情况下）达到1000～2000完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的处理经验，这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到。

#### 方法区和运行时常量池溢出

由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。前面提到JDK 1.7开始逐步“去永久代”的事情，在此就以测试代码观察一下这件事对程序的实际影响。

​    

String.intern（）是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX：PermSize和-XX：MaxPermSize限制方法区大小，从而间接限制其中常量池的容量，如代码清单2-6所示。

问题解决： 就是类太多了

#### 本机直接内存溢出

-  -XX： MaxDirectMemorySize    默认与Java堆最大值一样。
- 通过 DirectByteBuffer  或者 Unsafe实例可以使用直接内存

由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。