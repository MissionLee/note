# SQL语法规范

## 建表规约

- 是否概念字段 必须使用`is_xxx`的方式命名,数据类型`unsigned tinyint`
- 任何字段如果`非负数`,必须是`unsigned`
- 表名,字段名必须使用小写`字母`,`数字`,`禁止数字开头`,`禁止下划线之间只出现数字`.
- 表明不使用复数名词
- 禁用保留字
- `主键索引名为pk_字段名`
- `唯一索引名为uk_字段名`
- `普通索引名为idx_字段名`
- `小数类型使用decimal`禁止使用float,double,如果存储范围超过decimal,数据的整数和小数部分拆分
- 如果存储的字符串长度几乎相等,使用`char定长字符串`类型
- varchar长度不要超过5000,超过此长度`使用text类型`,`独立处一张表`,用主键来对应,避免影响其他字段索引效率
- 表必备三个字段: `id,gmt_create,gmt_modified`,其中id必为主键,类型unsigned bigint,自增,步长为1;gmt_createhe gmt_modified的类型均为date_time(gmt是Greenwich mean time)
- 表名称为`业务名称_表的作用`
- 库名誉应用名称尽量一直
- 修改字段还以,或对字段表示的状态追加时,需要及时更新字段注释
- 字段允许适当冗余,以提高查询性能,但是必须考虑数据一致.冗余字段遵循:
  - 不是频繁修改的字段
  - 不是varchar超长或其他超长字段
  - 主要目的是`减少关联查询`

## 索引规约

- 业务上有唯一特性的字段,即使是多个字段的组合,也`必须建成唯一索引`.
- `超过三个表禁止join`,需要join的阻断,数据类型必须绝对一直;多表关联查询时,保证`被关联的字段需要有索引`
- varchar字段上建立索引是,必须`指定索引长度`,没必要对全字段建立索引,根据文本区分度决定索引长度即可.
- 页面搜索`禁止左模糊或者全模糊`,如果需要请走搜索引擎来解决.
- 如果有order by的场景,请注意利用索引的`有序性`.order by最后的字段是组合索引的一部分,并且放在索引组合顺序的最后,避免出现`file_sort`的情况,影响查询性能
  - 正例: `where a = ? and b = ? order by c;`索引a_b_c
  - 反例: 搜索中有范围查找,索引有序性无法利用`where a>10 order by b`索引a_b无法排序
- 利用覆盖索引来进行查询操作,避免回表
  - 能够建立索引的种类:主键索引,唯一索引,普通索引,而覆盖索引是一种查询的一种效果,用explain的结果,extra列会出现:using index
- 利用延迟关联或者子查询优化超多分页的场景
  - 说明:MySQL并不是跳过offset行,而是取 offset+N行,然后返回N行,当offset很大的时候,效率非常地下
  - select a.* from 表1 a,(select id from 表1 where 条件 LIMIT 100000,20) b where a.id = b.id;
- SQL性能优化的目标:至少达到range级别,要求是ref级别,如果是consts最好
  - consts 单表中最多只有一个匹配行(主键或唯一索引),在优化阶段集合都导数据[唯一匹配查询]
  - ref 指的是使用普通的索引(normal index) [普通索引查询]
  - range 对索引进行范围检索[范围查询]
  - 反例: explain表的结果,type=index,索引物理文件全扫描,速度非常慢,这个index级别比较range还低,与全表扫描小巫见大巫
- 建组合索引的时候,区分度最高的在最坐标
  - where a = ? and b = ? ,a列几乎接近于唯一值,那么只需要单建立 idx_a索引即可
  - 存在等号和非等号混合判断条件时,等号的放在前面
- 防止因字段类型不同造成饮食转换,导致索引失效
- 创建索引时,避免如下极端误解:
  - `宁滥勿缺`.认为有一个查询,就要建立一个索引
  - `宁缺毋滥`.认为索引会消耗空间,严重拖慢更新和新增速度.
  - `抵制唯一索引`.认为业务的唯一性,一律需要在应用层通过"先查后插"方式解决